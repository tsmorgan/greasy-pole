<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Climber Sequence Game + Sine Wave Water</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="styles.css">
    </head>
    <body>
        <canvas id="liquidCanvas"></canvas>
        <div class="status" id="status"></div>
        <div class="flash-message" id="flash"></div>
        <div class="button-grid" id="buttonGrid"></div>
        <div class="choice-overlay" style="display:none;" id="choiceOverlay">
            <div class="choice-overlay-container">
                <div id="choicelabel">Choose number of buttons for next round:</div>
                <div class="choice-buttons" id="choiceButtons"></div>
            </div>
        </div>

        <script>
            const LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            let BUTTON_COUNT = 3;

            // Define manually for now
            let WRONG_PX = Math.round(BUTTON_COUNT * 2 / 3);
            let CORRECT_PX = WRONG_PX * 2;
            let COMPLETE_PX = BUTTON_COUNT * 10;

            let buttons = [];
            let targetSequence = [];
            let userSequence = [];
            let gameOver = false;
            let underTimer = 0;
            let gameStartTime = null; // null until round starts
            let gamePaused = true; // new flag

            const canvas = document.getElementById('liquidCanvas');
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + "px";
            canvas.style.height = window.innerHeight + "px";
            ctx.scale(dpr, dpr);

            let t = 0;
            let baseY;
            let destY;
            const riseSpeed = Math.round(100 * canvas.height / 7500)/100;
            console.log(riseSpeed)
            let elapsedTime;

            const flashDiv = document.getElementById('flash');
            let flashTimeout;
            let flashMessage = '';
            function showFlash(msg, persistent = false) {
                flashMessage = msg;
                flashDiv.textContent = msg;
                flashDiv
                    .classList
                    .add('flash-show');
                if (!persistent) {
                    clearTimeout(flashTimeout);
                    flashTimeout = setTimeout(() => {
                        flashDiv
                            .classList
                            .remove('flash-show');
                    }, 1500);
                } else {
                    flashDiv
                        .classList
                        .add('persistent');
                }
            }

            function shuffleArray(array) {
                const arr = [...array];
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [
                        arr[i], arr[j]
                    ] = [
                        arr[j], arr[i]
                    ];
                }
                return arr;
            }

            function newGame() {
                gameOver = false;
                underTimer = 0;
                gameStartTime = Date.now();
                elapsedTime = 0;
                gamePaused = false;
                baseY = 6 * canvas.height / 7; // start water at bottom
                destY = baseY;
            }

            const buttonGrid = document.getElementById('buttonGrid');
            function newRound() {
                WRONG_PX = Math.round(BUTTON_COUNT * 2 / 3);
                CORRECT_PX = WRONG_PX * 2;
                COMPLETE_PX = BUTTON_COUNT * 10;

                const lettersArray = shuffleArray(LETTERS.split('')).slice(0, BUTTON_COUNT);
                buttons = lettersArray.map((letter, index) => ({id: `btn-${index}`, letter, correct: false}));
                targetSequence = shuffleArray([...lettersArray]);
                userSequence = [];
                gamePaused = false;

                buttonGrid.innerHTML = '';
                const row1 = document.createElement('div');
                row1.className = 'button-row';
                const row2 = document.createElement('div');
                row2.className = 'button-row';

                const midpoint = Math.ceil(BUTTON_COUNT / 2);
                buttons
                    .slice(0, midpoint)
                    .forEach(b => {
                        const btn = document.createElement('button');
                        btn.id = b.id;
                        btn.textContent = b.letter;
                        btn.onclick = () => handleClick(b);
                        row1.appendChild(btn);
                    });
                buttons
                    .slice(midpoint)
                    .forEach(b => {
                        const btn = document.createElement('button');
                        btn.id = b.id;
                        btn.textContent = b.letter;
                        btn.onclick = () => handleClick(b);
                        row2.appendChild(btn);
                    });
                buttonGrid.appendChild(row1);
                buttonGrid.appendChild(row2);
                showButtons(true)
            }

            function showButtons(show = false) {
                if (show) 
                    buttonGrid
                        .classList
                        .remove('hidden');
                else 
                    buttonGrid
                        .classList
                        .add('hidden');
                }
            
            function handleClick(button) {
                if (gameOver || button.correct || gamePaused) 
                    return;
                const nextLetter = targetSequence[userSequence.length];
                const btnElem = document.getElementById(button.id);
                if (button.letter === nextLetter) {
                    userSequence.push(button.letter);
                    destY += CORRECT_PX; // lower the water when correct
                    button.correct = true;
                    btnElem
                        .classList
                        .add('correct');
                    // showFlash('Correct!');

                    if (userSequence.length === targetSequence.length) {
                        showFlash('Round Complete!');
                        destY += COMPLETE_PX; // sink the water more
                        showButtons(false);
                        setTimeout(() => nextRound(), 1000);
                    }

                } else {
                    destY -= WRONG_PX; // raise the water when wrong
                    if (destY < 0) 
                        destY = 0;
                    userSequence = [];
                    btnElem
                        .classList
                        .add('wrong');
                    setTimeout(() => btnElem.classList.remove('wrong'), 1000);
                    buttons.forEach(b => {
                        if (b.correct) {
                            document
                                .getElementById(b.id)
                                .classList
                                .remove('correct');
                            b.correct = false;
                        }
                    });
                }
            }

            function nextRound() {
                if (gameOver) 
                    return;
                if (BUTTON_COUNT < 9) {
                    BUTTON_COUNT++;
                    newRound();
                } else {
                    gameOver = true;
                }
            }

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                baseY = canvas.height; // reset water at bottom on resize
                destY = baseY;
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            const statusDiv = document.getElementById('status');

            function draw() {
                const width = canvas.width;
                const height = canvas.height;
                ctx.clearRect(0, 0, width, height);

                const boxWidth = 50;
                const boxX = width / 2 - boxWidth / 2;
                const boxY = 2 * height / 7 - boxWidth / 2; // square in center

                if (!gameOver && !gamePaused) {
                    destY -= riseSpeed; // water always rises slowly
                    if (destY < 0) 
                        destY = 0;
                    }
                
                // Smoothly approach destY
                baseY += (destY - baseY) * 0.05;

                const amplitude = Math.max(10, height * 0.02);
                const wavelength = 130;
                const speed = 1.5;

                function drawWave(alter = 1) {
                    ctx.beginPath();
                    ctx.moveTo(0, height);
                    let y;
                    for (let x = 1; x <= width; x += 50) {
                        y = baseY + Math.sin(((x * alter) + t) / wavelength) * amplitude;
                        ctx.lineTo(x, y);
                    }
                    ctx.lineTo(width, y);
                    ctx.lineTo(width, height);
                    ctx.closePath();
                    ctx.fillStyle = '#3278f07F';
                    ctx.fill();
                }

                drawWave(1);
                ctx.fillStyle = '#f04c32';
                ctx.fillRect(boxX, boxY, boxWidth, boxWidth);
                drawWave(1.3);

                let status = 'OVER';
                if (boxY > baseY) {
                    status = 'UNDER';
                    if (!gamePaused) {
                        underTimer += 1 / 60;
                        if (underTimer >= 5 && !gameOver) {
                            gameOver = true;
                            showFlash('Game Over!', true);
                            showButtons(false);
                        }
                    }
                } else {
                    underTimer = 0;
                }

                if (!gameOver && !gamePaused && gameStartTime) 
                    elapsedTime = ((Date.now() - gameStartTime) / 1000).toFixed(1);
                
                // statusDiv.innerHTML = `Water Y: ${baseY.toFixed(0)} (Dest: ${destY.toFixed(0)})<br>Status: ${status}<br>Time: ${elapsedTime || 0}s<br>Flash: ${flashMessage}`;

                t += speed;
                requestAnimationFrame(draw);
            }

            newGame();
            nextRound();
            draw();
        </script>
    </body>
</html>